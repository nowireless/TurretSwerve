package com.kennedyrobotics.hardware.motors.ctre;

import com.ctre.phoenix.ErrorCode;
import com.ctre.phoenix.motorcontrol.DemandType;
import com.ctre.phoenix.motorcontrol.SupplyCurrentLimitConfiguration;
import com.ctre.phoenix.motorcontrol.TalonSRXControlMode;
import com.ctre.phoenix.motorcontrol.TalonSRXFeedbackDevice;
import com.ctre.phoenix.motorcontrol.can.TalonSRXConfiguration;
import com.ctre.phoenix.motorcontrol.can.TalonSRXPIDSetConfiguration;

public interface ITalonSRX extends IMotorControllerEnhanced {

    /**
     * Sets the appropriate output on the talon, depending on the mode.
     * @param mode The output mode to apply.
     * In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
     * In Current mode, output value is in amperes.
     * In Velocity mode, output value is in position change / 100ms.
     * In Position mode, output value is in encoder ticks or an analog value,
     *   depending on the sensor.
     * In Follower mode, the output value is the integer device ID of the talon to
     * duplicate.
     *
     * @param value The setpoint value, as described above.
     *
     *
     *	Standard Driving Example:
     *	_talonLeft.set(ControlMode.PercentOutput, leftJoy);
     *	_talonRght.set(ControlMode.PercentOutput, rghtJoy);
     */
    public void set(TalonSRXControlMode mode, double value);

    /**
     * @param mode Sets the appropriate output on the talon, depending on the mode.
     * @param demand0 The output value to apply.
     * 	such as advanced feed forward and/or auxiliary close-looping in firmware.
     * In PercentOutput, the output is between -1.0 and 1.0, with 0.0 as stopped.
     * In Current mode, output value is in amperes.
     * In Velocity mode, output value is in position change / 100ms.
     * In Position mode, output value is in encoder ticks or an analog value,
     *   depending on the sensor. See
     * In Follower mode, the output value is the integer device ID of the talon to
     * duplicate.
     *
     * @param demand1Type The demand type for demand1.
     * Neutral: Ignore demand1 and apply no change to the demand0 output.
     * AuxPID: Use demand1 to set the target for the auxiliary PID 1.  Auxiliary
     *   PID is always executed as standard Position PID control.
     * ArbitraryFeedForward: Use demand1 as an arbitrary additive value to the
     *	 demand0 output.  In PercentOutput the demand0 output is the motor output,
     *   and in closed-loop modes the demand0 output is the output of PID0.
     * @param demand1 Supplmental output value.
     * AuxPID: Target position in Sensor Units
     * ArbitraryFeedForward: Percent Output between -1.0 and 1.0
     *
     *
     *  Arcade Drive Example:
     *		_talonLeft.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, +joyTurn);
     *		_talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.ArbitraryFeedForward, -joyTurn);
     *
     *	Drive Straight Example:
     *	Note: Selected Sensor Configuration is necessary for both PID0 and PID1.
     *		_talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
     *		_talonRght.set(ControlMode.PercentOutput, joyForward, DemandType.AuxPID, desiredRobotHeading);
     *
     *	Drive Straight to a Distance Example:
     *	Note: Other configurations (sensor selection, PID gains, etc.) need to be set.
     *		_talonLeft.follow(_talonRght, FollwerType.AuxOutput1);
     *		_talonRght.set(ControlMode.MotionMagic, targetDistance, DemandType.AuxPID, desiredRobotHeading);
     */
    public void set(TalonSRXControlMode mode, double demand0, DemandType demand1Type, double demand1);

    /**
     * @return object that can get/set individual raw sensor values.
     */
    public ISensorCollection getISensorCollection();

    /**
     * Select the feedback device for the motor controller.
     *
     * @param feedbackDevice
     *            Talon SRX Feedback Device to select.
     * @param pidIdx
     *            0 for Primary closed-loop. 1 for auxiliary closed-loop.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSelectedFeedbackSensor(TalonSRXFeedbackDevice feedbackDevice, int pidIdx, int timeoutMs);

    /**
     * Configures the supply (input) current limit.
     * @param currLimitConfigs  Current limit configuration
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSupplyCurrentLimit(SupplyCurrentLimitConfiguration currLimitConfigs, int timeoutMs);

    /**
     * Configures the supply (input) current limit.
     * @param currLimitConfigs  Current limit configuration
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSupplyCurrentLimit(SupplyCurrentLimitConfiguration currLimitConfigs);

    /**
     * Configure the peak allowable current (when current limit is enabled).
     *
     * Supply current limiting is also available via configSupplyCurrentLimit(),
     * which is a common routine with Talon FX.
     *
     * Current limit is activated when current exceeds the peak limit for longer
     * than the peak duration. Then software will limit to the continuous limit.
     * This ensures current limiting while allowing for momentary excess current
     * events.
     *
     * For simpler current-limiting (single threshold) use
     * ConfigContinuousCurrentLimit() and set the peak to zero:
     * ConfigPeakCurrentLimit(0).
     *
     * @param amps
     *            Amperes to limit.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configPeakCurrentLimit(int amps, int timeoutMs);

    /**
     * Configure the peak allowable current (when current limit is enabled).
     *
     * Supply current limiting is also available via configSupplyCurrentLimit(),
     * which is a common routine with Talon FX.
     *
     * Current limit is activated when current exceeds the peak limit for longer
     * than the peak duration. Then software will limit to the continuous limit.
     * This ensures current limiting while allowing for momentary excess current
     * events.
     *
     * For simpler current-limiting (single threshold) use
     * ConfigContinuousCurrentLimit() and set the peak to zero:
     * ConfigPeakCurrentLimit(0).
     *
     * @param amps
     *            Amperes to limit.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configPeakCurrentLimit(int amps);

    /**
     * Configure the peak allowable duration (when current limit is enabled).
     *
     * Supply current limiting is also available via configSupplyCurrentLimit(),
     * which is a common routine with Talon FX.
     *
     * Current limit is activated when current exceeds the peak limit for longer
     * than the peak duration. Then software will limit to the continuous limit.
     * This ensures current limiting while allowing for momentary excess current
     * events.
     *
     * For simpler current-limiting (single threshold) use
     * ConfigContinuousCurrentLimit() and set the peak to zero:
     * ConfigPeakCurrentLimit(0).
     *
     * @param milliseconds
     *            How long to allow current-draw past peak limit.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configPeakCurrentDuration(int milliseconds, int timeoutMs);

    /**
     * Configure the peak allowable duration (when current limit is enabled).
     *
     * Supply current limiting is also available via configSupplyCurrentLimit(),
     * which is a common routine with Talon FX.
     *
     * Current limit is activated when current exceeds the peak limit for longer
     * than the peak duration. Then software will limit to the continuous limit.
     * This ensures current limiting while allowing for momentary excess current
     * events.
     *
     * For simpler current-limiting (single threshold) use
     * ConfigContinuousCurrentLimit() and set the peak to zero:
     * ConfigPeakCurrentLimit(0).
     *
     * @param milliseconds
     *            How long to allow current-draw past peak limit.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configPeakCurrentDuration(int milliseconds);

    /**
     * Configure the continuous allowable current-draw (when current limit is
     * enabled).
     *
     * Supply current limiting is also available via configSupplyCurrentLimit(),
     * which is a common routine with Talon FX.
     *
     * Current limit is activated when current exceeds the peak limit for longer
     * than the peak duration. Then software will limit to the continuous limit.
     * This ensures current limiting while allowing for momentary excess current
     * events.
     *
     * For simpler current-limiting (single threshold) use
     * ConfigContinuousCurrentLimit() and set the peak to zero:
     * ConfigPeakCurrentLimit(0).
     *
     * @param amps
     *            Amperes to limit.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configContinuousCurrentLimit(int amps, int timeoutMs);

    /**
     * Configure the continuous allowable current-draw (when current limit is
     * enabled).
     *
     * Supply current limiting is also available via configSupplyCurrentLimit(),
     * which is a common routine with Talon FX.
     *
     * Current limit is activated when current exceeds the peak limit for longer
     * than the peak duration. Then software will limit to the continuous limit.
     * This ensures current limiting while allowing for momentary excess current
     * events.
     *
     * For simpler current-limiting (single threshold) use
     * ConfigContinuousCurrentLimit() and set the peak to zero:
     * ConfigPeakCurrentLimit(0).
     *
     * @param amps
     *            Amperes to limit.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configContinuousCurrentLimit(int amps);

    /**
     * Enable or disable Current Limit.
     *
     * Supply current limiting is also available via configSupplyCurrentLimit(),
     * which is a common routine with Talon FX.
     *
     * @param enable
     *            Enable state of current limit.
     * @see #configPeakCurrentLimit(int,int)
     * @see #configPeakCurrentDuration(int,int)
     * @see #configContinuousCurrentLimit(int,int)
     */
    public void enableCurrentLimit(boolean enable);

    /**
     * Gets all PID set persistant settings.
     *
     * @param pid               Object with all of the PID set persistant settings
     * @param pidIdx            0 for Primary closed-loop. 1 for auxiliary closed-loop.
     * @param timeoutMs
     *              Timeout value in ms. If nonzero, function will wait for
     *              config success and report an error if it times out.
     *              If zero, no blocking or checking is performed.
     */
    public void getPIDConfigs(TalonSRXPIDSetConfiguration pid, int pidIdx, int timeoutMs);

    /**
     * Gets all PID set persistant settings (overloaded so timeoutMs is 50 ms
     * and pidIdx is 0).
     *
     * @param pid               Object with all of the PID set persistant settings
     */
    public void getPIDConfigs(TalonSRXPIDSetConfiguration pid);

    /**
     * Configures all persistent settings.
     *
     * @param allConfigs        Object with all of the persistant settings
     * @param timeoutMs
     *              Timeout value in ms. If nonzero, function will wait for
     *              config success and report an error if it times out.
     *              If zero, no blocking or checking is performed.
     *
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configAllSettings(TalonSRXConfiguration allConfigs, int timeoutMs);

    /**
     * Configures all persistent settings (overloaded so timeoutMs is 50 ms).
     *
     * @param allConfigs        Object with all of the persistant settings
     *
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configAllSettings(TalonSRXConfiguration allConfigs);

    /**
     * Gets all persistant settings.
     *
     * @param allConfigs        Object with all of the persistant settings
     * @param timeoutMs
     *              Timeout value in ms. If nonzero, function will wait for
     *              config success and report an error if it times out.
     *              If zero, no blocking or checking is performed.
     */
    public void getAllConfigs(TalonSRXConfiguration allConfigs, int timeoutMs);

    /**
     * Gets all persistant settings (overloaded so timeoutMs is 50 ms).
     *
     * @param allConfigs        Object with all of the persistant settings
     */
    public void getAllConfigs(TalonSRXConfiguration allConfigs);


}
