package com.kennedyrobotics.hardware.motors.ctre;

import com.ctre.phoenix.ErrorCode;
import com.ctre.phoenix.ParamEnum;
import com.ctre.phoenix.motion.BufferedTrajectoryPointStream;
import com.ctre.phoenix.motorcontrol.*;
import com.ctre.phoenix.motorcontrol.can.BaseTalon;
import com.ctre.phoenix.motorcontrol.can.FilterConfiguration;
import com.ctre.phoenix.motorcontrol.can.SlotConfiguration;
import com.ctre.phoenix.sensors.CANCoder;
import com.ctre.phoenix.sensors.SensorVelocityMeasPeriod;
import com.kennedyrobotics.hardware.sensors.ctre.ICANCoder;

/**
 * Contains methods defined in {@link com.ctre.phoenix.motorcontrol.can.BaseMotorController}
 * but not present in {@link com.ctre.phoenix.motorcontrol.IMotorController}.
 *
 * Does not contain deprecated methods of {@link com.ctre.phoenix.motorcontrol.can.BaseMotorController}.
 */
public interface IBaseMotorController extends com.ctre.phoenix.motorcontrol.IMotorController {
    // Added method for our interface scheme
    /**
     * Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
     * After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
     * as a PID source for closed-loop features.
     *
     * @param canCoderRef
     *            CANCoder device reference to use.
     * @param remoteOrdinal
     *            0 for configuring Remote Sensor 0,
     *            1 for configuring Remote Sensor 1
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configRemoteFeedbackFilter(ICANCoder canCoderRef, int remoteOrdinal, int timeoutMs);

    /**
     * Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
     * After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
     * as a PID source for closed-loop features.
     *
     * @param canCoderRef
     *            CANCoder device reference to use.
     * @param remoteOrdinal
     *            0 for configuring Remote Sensor 0,
     *            1 for configuring Remote Sensor 1
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configRemoteFeedbackFilter(ICANCoder canCoderRef, int remoteOrdinal);

    // Missing methods from IMotorController
    /**
     * Revert all configurations to factory default values.
     * Use this before your individual config* calls to avoid having to config every single param.
     *
     * Alternatively you can use the configAllSettings routine.
     *
     * @param timeoutMs
     *            Timeout value in ms. Function will generate error if config is
     *            not successful within timeout.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configFactoryDefault(int timeoutMs);

    /**
     * Revert all configurations to factory default values.
     * Use this before your individual config* calls to avoid having to config every single param.
     *
     * Alternatively you can use the configAllSettings routine.
     *
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configFactoryDefault();

    /**
     * Configures the open-loop ramp rate of throttle output.
     *
     * @param secondsFromNeutralToFull
     *            Minimum desired time to go from neutral to full throttle. A
     *            value of '0' will disable the ramp.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configOpenloopRamp(double secondsFromNeutralToFull);

    /**
     * Configures the closed-loop ramp rate of throttle output.
     *
     * @param secondsFromNeutralToFull
     *            Minimum desired time to go from neutral to full throttle. A
     *            value of '0' will disable the ramp.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configClosedloopRamp(double secondsFromNeutralToFull);

    /**
     * Configures the forward peak output percentage.
     *
     * @param percentOut
     *            Desired peak output percentage. [0,1]
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configPeakOutputForward(double percentOut, int timeoutMs);

    /**
     * Configures the reverse peak output percentage.
     *
     * @param percentOut
     *            Desired peak output percentage.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configPeakOutputReverse(double percentOut);

    /**
     * Configures the forward nominal output percentage.
     *
     * @param percentOut
     *            Nominal (minimum) percent output. [0,+1]
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configNominalOutputForward(double percentOut);

    /**
     * Configures the reverse nominal output percentage.
     *
     * @param percentOut
     *            Nominal (minimum) percent output. [-1,0]
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configNominalOutputReverse(double percentOut);

    /**
     * Configures the output deadband percentage.
     *
     * @param percentDeadband
     *            Desired deadband percentage. Minimum is 0.1%, Maximum is 25%.
     *            Pass 0.04 for 4% (factory default).
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configNeutralDeadband(double percentDeadband);

    /**
     * Configures the Voltage Compensation saturation voltage.
     *
     * @param voltage
     *            This is the max voltage to apply to the hbridge when voltage
     *            compensation is enabled.  For example, if 10 (volts) is specified
     *            and a TalonSRX is commanded to 0.5 (PercentOutput, closed-loop, etc)
     *            then the TalonSRX will attempt to apply a duty-cycle to produce 5V.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configVoltageCompSaturation(double voltage);

    /**
     * Configures the voltage measurement filter.
     *
     * @param filterWindowSamples
     *            Number of samples in the rolling average of voltage
     *            measurement.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configVoltageMeasurementFilter(int filterWindowSamples);

    /**
     * Returns the enable state of Voltage Compensation that the caller has set.
     *
     * @return TRUE if voltage compensation is enabled.
     */
    public boolean isVoltageCompensationEnabled();

    /**
     * Select the remote feedback device for the motor controller.
     * Most CTRE CAN motor controllers will support remote sensors over CAN.
     *
     * @param feedbackDevice
     *            Remote Feedback Device to select.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSelectedFeedbackSensor(RemoteFeedbackDevice feedbackDevice);

    /**
     * Select the feedback device for the motor controller.
     *
     * @param feedbackDevice
     *            Feedback Device to select.
     * @param pidIdx
     *            0 for Primary closed-loop. 1 for auxiliary closed-loop.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSelectedFeedbackSensor(FeedbackDevice feedbackDevice, int pidIdx, int timeoutMs);

    /**
     * Select the feedback device for the motor controller.
     *
     * @param feedbackDevice
     *            Feedback Device to select.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSelectedFeedbackSensor(FeedbackDevice feedbackDevice);

    /**
     * Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
     * After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
     * as a PID source for closed-loop features.
     *
     * @param deviceID
     *            The device ID of the remote sensor device.
     * @param remoteSensorSource
     *            The remote sensor device and signal type to bind.
     * @param remoteOrdinal
     *            0 for configuring Remote Sensor 0,
     *            1 for configuring Remote Sensor 1
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configRemoteFeedbackFilter(int deviceID, RemoteSensorSource remoteSensorSource, int remoteOrdinal,
                                                int timeoutMs);

    /**
     * Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
     * After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
     * as a PID source for closed-loop features.
     *
     * @param deviceID
     *            The device ID of the remote sensor device.
     * @param remoteSensorSource
     *            The remote sensor device and signal type to bind.
     * @param remoteOrdinal
     *            0 for configuring Remote Sensor 0,
     *            1 for configuring Remote Sensor 1
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configRemoteFeedbackFilter(int deviceID, RemoteSensorSource remoteSensorSource, int remoteOrdinal);

    /**
     * Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
     * After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
     * as a PID source for closed-loop features.
     *
     * @param canCoderRef
     *            CANCoder device reference to use.
     * @param remoteOrdinal
     *            0 for configuring Remote Sensor 0,
     *            1 for configuring Remote Sensor 1
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configRemoteFeedbackFilter(CANCoder canCoderRef, int remoteOrdinal);

    /**
     * Select what remote device and signal to assign to Remote Sensor 0 or Remote Sensor 1.
     * After binding a remote device and signal to Remote Sensor X, you may select Remote Sensor X
     * as a PID source for closed-loop features.
     *
     * @param talonRef
     *            Talon device reference to use.
     * @param remoteOrdinal
     *            0 for configuring Remote Sensor 0,
     *            1 for configuring Remote Sensor 1
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configRemoteFeedbackFilter(BaseTalon talonRef, int remoteOrdinal);

    /**
     * The Feedback Coefficient is a scalar applied to the value of the
     * feedback sensor.  Useful when you need to scale your sensor values
     * within the closed-loop calculations.  Default value is 1.
     *
     * Selected Feedback Sensor register in firmware is the decoded sensor value
     * multiplied by the Feedback Coefficient.
     *
     * @param coefficient
     *            Feedback Coefficient value.  Maximum value of 1.
     *						Resolution is 1/(2^16).  Cannot be 0.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSelectedFeedbackCoefficient(double coefficient);

    /**
     * Select what sensor term should be bound to switch feedback device.
     * Sensor Sum = Sensor Sum Term 0 - Sensor Sum Term 1
     * Sensor Difference = Sensor Diff Term 0 - Sensor Diff Term 1
     * The four terms are specified with this routine.  Then Sensor Sum/Difference
     * can be selected for closed-looping.
     *
     * @param sensorTerm Which sensor term to bind to a feedback source.
     * @param feedbackDevice The sensor signal to attach to sensorTerm.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSensorTerm(SensorTerm sensorTerm, FeedbackDevice feedbackDevice);

    /**
     * Select what sensor term should be bound to switch feedback device.
     * Sensor Sum = Sensor Sum Term 0 - Sensor Sum Term 1
     * Sensor Difference = Sensor Diff Term 0 - Sensor Diff Term 1
     * The four terms are specified with this routine.  Then Sensor Sum/Difference
     * can be selected for closed-looping.
     *
     * @param sensorTerm Which sensor term to bind to a feedback source.
     * @param feedbackDevice The sensor signal to attach to sensorTerm.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSensorTerm(SensorTerm sensorTerm, RemoteFeedbackDevice feedbackDevice, int timeoutMs);

    /**
     * Select what sensor term should be bound to switch feedback device.
     * Sensor Sum = Sensor Sum Term 0 - Sensor Sum Term 1
     * Sensor Difference = Sensor Diff Term 0 - Sensor Diff Term 1
     * The four terms are specified with this routine.  Then Sensor Sum/Difference
     * can be selected for closed-looping.
     *
     * @param sensorTerm Which sensor term to bind to a feedback source.
     * @param feedbackDevice The sensor signal to attach to sensorTerm.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSensorTerm(SensorTerm sensorTerm, RemoteFeedbackDevice feedbackDevice);

    /**
     * Get the selected sensor position (in raw sensor units).
     *
     * @return Position of selected sensor (in raw sensor units).
     */
    public double getSelectedSensorPosition();

    /**
     * Get the selected sensor velocity.
     *
     * @return selected sensor (in raw sensor units) per 100ms.
     * See Phoenix-Documentation for how to interpret.
     */
    public double getSelectedSensorVelocity();

    /**
     * Sets the sensor position to the given value.
     *
     * @param sensorPos
     *            Position to set for the selected sensor (in raw sensor units).
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode setSelectedSensorPosition(double sensorPos);

    /**
     * Sets the period of the given status frame.
     *
     * User ensure CAN Bus utilization is not high.
     *
     * This setting is not persistent and is lost when device is reset.
     * If this is a concern, calling application can use hasResetOccurred()
     * to determine if the status frame needs to be reconfigured.
     *
     * @param frame
     *            Frame whose period is to be changed.
     * @param periodMs
     *            Period in ms for the given frame.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode setControlFramePeriod(int frame, int periodMs);

    /**
     * Sets the period of the given status frame.
     *
     * User ensure CAN Bus utilization is not high.
     *
     * This setting is not persistent and is lost when device is reset. If this
     * is a concern, calling application can use hasResetOccurred() to determine if the
     * status frame needs to be reconfigured.
     *
     * @param frameValue
     *            Frame whose period is to be changed.
     * @param periodMs
     *            Period in ms for the given frame.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode setStatusFramePeriod(int frameValue, int periodMs);

    /**
     * Sets the period of the given status frame.
     *
     * @param frame
     *            Frame whose period is to be changed.
     * @param periodMs
     *            Period in ms for the given frame.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode setStatusFramePeriod(StatusFrame frame, int periodMs);

    /**
     * Gets the period of the given status frame.
     *
     * @param frame
     *            Frame to get the period of.
     * @return Period of the given status frame.
     */
    public int getStatusFramePeriod(int frame);

    /**
     * Gets the period of the given status frame.
     *
     * @param frame
     *            Frame to get the period of.
     * @return Period of the given status frame.
     */
    public int getStatusFramePeriod(StatusFrame frame);

    /**
     * Gets the period of the given status frame.
     *
     * @param frame
     *            Frame to get the period of.
     * @return Period of the given status frame.
     */
    public int getStatusFramePeriod(StatusFrameEnhanced frame);

    /**
     * Sets the period over which velocity measurements are taken.
     *
     * @param period
     *            Desired period for the velocity measurement. @see
     *            com.ctre.phoenix.sensors.SensorVelocityMeasPeriod
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configVelocityMeasurementPeriod(SensorVelocityMeasPeriod period, int timeoutMs);

    /**
     * Sets the period over which velocity measurements are taken.
     *
     * @param period
     *            Desired period for the velocity measurement. @see
     *            com.ctre.phoenix.sensors.SensorVelocityMeasPeriod
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configVelocityMeasurementPeriod(SensorVelocityMeasPeriod period);

    /**
     * Sets the number of velocity samples used in the rolling average velocity
     * measurement.
     *
     * @param windowSize
     *            Number of samples in the rolling average of velocity
     *            measurement. Valid values are 1,2,4,8,16,32. If another value
     *            is specified, it will truncate to nearest support value.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configVelocityMeasurementWindow(int windowSize, int timeoutMs);

    /**
     * Sets the number of velocity samples used in the rolling average velocity
     * measurement.
     *
     * @param windowSize
     *            Number of samples in the rolling average of velocity
     *            measurement. Valid values are 1,2,4,8,16,32. If another value
     *            is specified, it will truncate to nearest support value.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configVelocityMeasurementWindow(int windowSize);

    /**
     * Configures the forward limit switch for a remote source. For example, a
     * CAN motor controller may need to monitor the Limit-F pin of another Talon
     * or CANifier.
     *
     * @param type
     *            Remote limit switch source. User can choose between a remote
     *            Talon SRX, CANifier, or deactivate the feature.
     * @param normalOpenOrClose
     *            Setting for normally open, normally closed, or disabled. This
     *            setting matches the Phoenix Tuner drop down.
     * @param deviceID
     *            Device ID of remote source (Talon SRX or CANifier device ID).
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configForwardLimitSwitchSource(RemoteLimitSwitchSource type, LimitSwitchNormal normalOpenOrClose,
                                                    int deviceID, int timeoutMs);

    /**
     * Configures the forward limit switch for a remote source. For example, a
     * CAN motor controller may need to monitor the Limit-F pin of another Talon
     * or CANifier.
     *
     * @param type
     *            Remote limit switch source. User can choose between a remote
     *            Talon SRX, CANifier, or deactivate the feature.
     * @param normalOpenOrClose
     *            Setting for normally open, normally closed, or disabled. This
     *            setting matches the Phoenix Tuner drop down.
     * @param deviceID
     *            Device ID of remote source (Talon SRX or CANifier device ID).
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configForwardLimitSwitchSource(RemoteLimitSwitchSource type, LimitSwitchNormal normalOpenOrClose,
                                                    int deviceID);

    /**
     * Configures the reverse limit switch for a remote source. For example, a
     * CAN motor controller may need to monitor the Limit-R pin of another Talon
     * or CANifier.
     *
     * @param type
     *            Remote limit switch source. User can choose between a remote
     *            Talon SRX, CANifier, or deactivate the feature.
     * @param normalOpenOrClose
     *            Setting for normally open, normally closed, or disabled. This
     *            setting matches the Phoenix Tuner drop down.
     * @param deviceID
     *            Device ID of remote source (Talon SRX or CANifier device ID).
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configReverseLimitSwitchSource(RemoteLimitSwitchSource type, LimitSwitchNormal normalOpenOrClose,
                                                    int deviceID, int timeoutMs);

    /**
     * Configures the reverse limit switch for a remote source. For example, a
     * CAN motor controller may need to monitor the Limit-R pin of another Talon
     * or CANifier.
     *
     * @param type
     *            Remote limit switch source. User can choose between a remote
     *            Talon SRX, CANifier, or deactivate the feature.
     * @param normalOpenOrClose
     *            Setting for normally open, normally closed, or disabled. This
     *            setting matches the Phoenix Tuner drop down.
     * @param deviceID
     *            Device ID of remote source (Talon SRX or CANifier device ID).
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configReverseLimitSwitchSource(RemoteLimitSwitchSource type, LimitSwitchNormal normalOpenOrClose,
                                                    int deviceID);

    /**
     * Configures a limit switch for a local/remote source.
     *
     * For example, a CAN motor controller may need to monitor the Limit-R pin
     * of another Talon, CANifier, or local Gadgeteer feedback connector.
     *
     * If the sensor is remote, a device ID of zero is assumed. If that's not
     * desired, use the four parameter version of this function.
     *
     * @param type
     *            Limit switch source. @see com.ctre.phoenix.motorcontrol.LimitSwitchSource User can choose
     *            between the feedback connector, remote Talon SRX, CANifier, or
     *            deactivate the feature.
     * @param normalOpenOrClose
     *            Setting for normally open, normally closed, or disabled. This
     *            setting matches the Phoenix Tuner drop down.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for config
     *            success and report an error if it times out. If zero, no
     *            blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configForwardLimitSwitchSource(LimitSwitchSource type, LimitSwitchNormal normalOpenOrClose,
                                                    int timeoutMs);

    /**
     * Configures a limit switch for a local/remote source.
     *
     * For example, a CAN motor controller may need to monitor the Limit-R pin
     * of another Talon, CANifier, or local Gadgeteer feedback connector.
     *
     * If the sensor is remote, a device ID of zero is assumed. If that's not
     * desired, use the four parameter version of this function.
     *
     * @param type
     *            Limit switch source. @see com.ctre.phoenix.motorcontrol.LimitSwitchSource User can choose
     *            between the feedback connector, remote Talon SRX, CANifier, or
     *            deactivate the feature.
     * @param normalOpenOrClose
     *            Setting for normally open, normally closed, or disabled. This
     *            setting matches the Phoenix Tuner drop down.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configForwardLimitSwitchSource(LimitSwitchSource type, LimitSwitchNormal normalOpenOrClose);

    /**
     * Configures the forward soft limit threhold.
     *
     * @param forwardSensorLimit
     *            Forward Sensor Position Limit (in raw sensor units).
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configForwardSoftLimitThreshold(double forwardSensorLimit);

    /**
     * Configures the reverse soft limit threshold.
     *
     * @param reverseSensorLimit
     *            Reverse Sensor Position Limit (in raw sensor units).
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configReverseSoftLimitThreshold(double reverseSensorLimit);

    /**
     * Configures the forward soft limit enable.
     *
     * @param enable
     *            Forward Sensor Position Limit Enable.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configForwardSoftLimitEnable(boolean enable);

    /**
     * Configures the reverse soft limit enable.
     *
     * @param enable
     *            Reverse Sensor Position Limit Enable.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configReverseSoftLimitEnable(boolean enable);

    /**
     * Sets the 'P' constant in the given parameter slot.
     * This is multiplied by closed loop error in sensor units.
     * Note the closed loop output interprets a final value of 1023 as full output.
     * So use a gain of '0.25' to get full output if err is 4096u (Mag Encoder 1 rotation)
     *
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param value
     *            Value of the P constant.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode config_kP(int slotIdx, double value);

    /**
     * Sets the 'I' constant in the given parameter slot.
     * This is multiplied by accumulated closed loop error in sensor units every PID Loop.
     * Note the closed loop output interprets a final value of 1023 as full output.
     * So use a gain of '0.00025' to get full output if err is 4096u for 1000 loops (accumulater holds 4,096,000),
     * [which is equivalent to one CTRE mag encoder rotation for 1000 milliseconds].
     *
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param value
     *            Value of the I constant.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode config_kI(int slotIdx, double value);

    /**
     * Sets the 'D' constant in the given parameter slot.
     *
     * This is multiplied by derivative error (sensor units per PID loop, typically 1ms).
     * Note the closed loop output interprets a final value of 1023 as full output.
     * So use a gain of '250' to get full output if derr is 4096u (Mag Encoder 1 rotation) per 1000 loops (typ 1 sec)
     *
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param value
     *            Value of the D constant.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode config_kD(int slotIdx, double value);

    /**
     * Sets the 'F' constant in the given parameter slot.
     *
     * See documentation for calculation details.
     * If using velocity, motion magic, or motion profile,
     * use (1023 * duty-cycle / sensor-velocity-sensor-units-per-100ms).
     *
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param value
     *            Value of the F constant.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode config_kF(int slotIdx,  double value);

    /**
     * Sets the Integral Zone constant in the given parameter slot. If the
     * (absolute) closed-loop error is outside of this zone, integral
     * accumulator is automatically cleared. This ensures than integral wind up
     * events will stop after the sensor gets far enough from its target.
     *
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param izone
     *            Value of the Integral Zone constant (closed loop error units X
     *            1ms).
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode config_IntegralZone(int slotIdx, double izone);

    /**
     * Sets the allowable closed-loop error in the given parameter slot.
     *
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param allowableClosedLoopError
     *            Value of the allowable closed-loop error in sensor units (or sensor units per 100ms for velocity).
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configAllowableClosedloopError(int slotIdx, double allowableClosedLoopError);

    /**
     * Sets the maximum integral accumulator in the given parameter slot.
     *
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param iaccum
     *            Value of the maximum integral accumulator (closed loop error
     *            units X 1ms).
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configMaxIntegralAccumulator(int slotIdx, double iaccum);

    /**
     * Sets the peak closed-loop output.  This peak output is slot-specific and
     *   is applied to the output of the associated PID loop.
     * This setting is seperate from the generic Peak Output setting.
     *
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param percentOut
     *            Peak Percent Output from 0 to 1.  This value is absolute and
     *						the magnitude will apply in both forward and reverse directions.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configClosedLoopPeakOutput(int slotIdx, double percentOut);

    /**
     * Sets the loop time (in milliseconds) of the PID closed-loop calculations.
     * Default value is 1 ms.
     *
     * @param slotIdx
     *            Parameter slot for the constant.
     * @param loopTimeMs
     *            Loop timing of the closed-loop calculations.  Minimum value of
     *						1 ms, maximum of 64 ms.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configClosedLoopPeriod(int slotIdx, int loopTimeMs);

    /**
     * Configures the Polarity of the Auxiliary PID (PID1).
     *
     * Standard Polarity:
     *    Primary Output = PID0 + PID1,
     *    Auxiliary Output = PID0 - PID1,
     *
     * Inverted Polarity:
     *    Primary Output = PID0 - PID1,
     *    Auxiliary Output = PID0 + PID1,
     *
     * @param invert
     *            If true, use inverted PID1 output polarity.
     * @return Error Code
     */
    public ErrorCode configAuxPIDPolarity(boolean invert);

    /**
     * Sets the integral accumulator. Typically this is used to clear/zero the
     * integral accumulator, however some use cases may require seeding the
     * accumulator for a faster response.
     *
     * @param iaccum
     *            Value to set for the integral accumulator (closed loop error
     *            units X 1ms).
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode setIntegralAccumulator(double iaccum);

    /**
     * Gets the closed-loop error. The units depend on which control mode is in
     * use.
     *
     * If closed-loop is seeking a target sensor position, closed-loop error is the difference between target
     * and current sensor value (in sensor units.  Example 4096 units per rotation for CTRE Mag Encoder).
     *
     * If closed-loop is seeking a target sensor velocity, closed-loop error is the difference between target
     * and current sensor value (in sensor units per 100ms).
     *
     * If using motion profiling or Motion Magic, closed loop error is calculated against the current target,
     * and not the "final" target at the end of the profile/movement.
     *
     * See Phoenix-Documentation information on units.
     *
     * @return Closed-loop error value.
     */
    public double getClosedLoopError();

    /**
     * Gets the iaccum value.
     *
     * @return Integral accumulator value (Closed-loop error X 1ms).
     */
    public double getIntegralAccumulator();

    /**
     * Gets the derivative of the closed-loop error.
     *
     * @return The error derivative value.
     */
    public double getErrorDerivative();

    /**
     * Gets the current target of a given closed loop.
     *
     * @return The closed loop target.
     */
    public double getClosedLoopTarget();

    /**
     * Gets the active trajectory target position using
     * MotionMagic/MotionProfile control modes.
     *
     * @param pidIdx
     *            0 for Primary closed-loop. 1 for auxiliary closed-loop.
     * @return The Active Trajectory Position in sensor units.
     */
    public double getActiveTrajectoryPosition(int pidIdx);

    /**
     * Gets the active trajectory target velocity using
     * MotionMagic/MotionProfile control modes.
     *
     * @param pidIdx
     *            0 for Primary closed-loop. 1 for auxiliary closed-loop.
     * @return The Active Trajectory Velocity in sensor units per 100ms.
     */
    public double getActiveTrajectoryVelocity(int pidIdx);

    /**
     * Gets the active trajectory arbitrary feedforward for pid0 using
     * MotionMagic/MotionProfile control modes.
     *
     * @return The Active Trajectory ArbFeedFwd in units of percent output
     * 			(where 0.01 is 1%).
     */
    public double getActiveTrajectoryArbFeedFwd();

    /**
     * Gets the active trajectory arbitrary feedforward using
     * MotionMagic/MotionProfile control modes.
     *
     * @param pidIdx
     *            0 for Primary closed-loop. 1 for auxiliary closed-loop.
     * @return The Active Trajectory ArbFeedFwd in units of percent output
     * 			(where 0.01 is 1%).
     */
    public double getActiveTrajectoryArbFeedFwd(int pidIdx);

    /**
     * Sets the Motion Magic Cruise Velocity. This is the peak target velocity
     * that the motion magic curve generator can use.
     *
     * @param sensorUnitsPer100ms
     *            Motion Magic Cruise Velocity (in raw sensor units per 100 ms).
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configMotionCruiseVelocity(double sensorUnitsPer100ms);

    /**
     * Sets the Motion Magic Acceleration. This is the target acceleration that
     * the motion magic curve generator can use.
     *
     * @param sensorUnitsPer100msPerSec
     *            Motion Magic Acceleration (in raw sensor units per 100 ms per
     *            second).
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configMotionAcceleration(double sensorUnitsPer100msPerSec);

    /**
     * Sets the Motion Magic S Curve Strength.
     * Call this before using Motion Magic.
     * Modifying this during a Motion Magic action should be avoided.
     *
     * @param curveStrength
     *            0 to use Trapezoidal Motion Profile. [1,8] for S-Curve (greater value yields greater smoothing).
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configMotionSCurveStrength(int curveStrength);

    /**
     * Simple one-shot firing of a complete MP.
     * Starting in 2019, MPs can be fired by building a Buffered Trajectory Point Stream, and calling this routine.
     *
     * Once called, the motor controller software will automatically ...
     * [1] Clear the firmware buffer of trajectory points.
     * [2] Clear the underrun flags
     * [3] Reset an index within the Buffered Trajectory Point Stream (so that the same profile can be run again and again).
     * [4] Start a background thread to manage MP streaming (if not already running).
     * [5a] If current control mode already matches motionProfControlMode, set MPE Output to "Hold".
     * [5b] If current control mode does not matches motionProfControlMode, apply motionProfControlMode and set MPE Output to "Disable".
     * [6] Stream the trajectory points into the device's firmware buffer.
     * [7] Once motor controller has at least minBufferedPts worth in the firmware buffer, MP will automatically start (MPE Output set to "Enable").
     * [8] Wait until MP finishes, then transitions the Motion Profile Executor's output to "Hold".
     * [9] IsMotionProfileFinished() will now return true.
     *
     * Calling application can use IsMotionProfileFinished() to determine when internal state machine reaches [7].
     * Calling application can cancel MP by calling set().  Otherwise do not call set() until MP has completed.
     *
     * The legacy API from previous years requires the calling application to pass points via the ProcessMotionProfileBuffer and PushMotionProfileTrajectory.
     * This is no longer required if using this StartMotionProfile/IsMotionProfileFinished API.
     *
     * @param stream	A buffer that will be used to stream the trajectory points.  Caller can fill this container with the entire trajectory point, regardless of size.
     * @param minBufferedPts	Minimum number of firmware buffered points before starting MP.
     *							Do not exceed device's firmware buffer capacity or MP will never fire (120 for Motion Profile, or 60 for Motion Profile Arc).
     *							Recommendation value for this would be five to ten samples depending on timeDur of the trajectory point.
     * @param motionProfControlMode		Pass MotionProfile or MotionProfileArc.
     * @return nonzero error code if operation fails.
     */
    public ErrorCode startMotionProfile(BufferedTrajectoryPointStream stream, int minBufferedPts, ControlMode motionProfControlMode);

    /**
     * Determine if running MP is complete.
     * This requires using the StartMotionProfile routine to start the MP.
     * That is because managing the trajectory points is now done in a background thread (if StartMotionProfile is called).
     *
     * If calling application uses the legacy API  (more-complex buffering API) from previous years, than this API will
     * not return true.
     *
     * @return true if MP was started using StartMotionProfile, and it has completed execution (MPE is now in "hold").
     */
    public boolean isMotionProfileFinished();

    /**
     * Clear the "Has Underrun" flag. Typically this is called after application
     * has confirmed an underrun had occured.
     *
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode clearMotionProfileHasUnderrun();

    /**
     * When trajectory points are processed in the motion profile executer, the MPE determines
     * how long to apply the active trajectory point by summing baseTrajDurationMs with the
     * timeDur of the trajectory point (see TrajectoryPoint).
     *
     * This allows general selection of the execution rate of the points with 1ms resolution,
     * while allowing some degree of change from point to point.
     * @param baseTrajDurationMs The base duration time of every trajectory point.
     * 							This is summed with the trajectory points unique timeDur.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configMotionProfileTrajectoryPeriod(int baseTrajDurationMs);

    /**
     * When trajectory points are processed in the buffer, the motor controller can
     * linearly interpolate additional trajectory points between the buffered
     * points.  The time delta between these interpolated points is 1 ms.
     *
     * By default this feature is enabled.
     *
     * @param enable Whether to enable the trajectory point interpolation feature.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configMotionProfileTrajectoryInterpolationEnable(boolean enable, int timeoutMs);

    /**
     * When trajectory points are processed in the buffer, the motor controller can
     * linearly interpolate additional trajectory points between the buffered
     * points.  The time delta between these interpolated points is 1 ms.
     *
     * By default this feature is enabled.
     *
     * @param enable Whether to enable the trajectory point interpolation feature.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configMotionProfileTrajectoryInterpolationEnable(boolean enable);

    /**
     * Disables continuous tracking of the position for analog and pulse-width.
     * If the signal goes from 4095 to 0 (pulse-width) a motor controller will continue to read 4096 by default.
     * If overflow tracking is disabled, it will wrap to 0 (not continuous)
     *
     * If using pulse-width on CTRE Mag Encoder (within one rotation) or absolute analog sensor (within one rotation),
     * setting feedbackNotContinuous to true is recommended, to prevent intermittent
     * connections from causing sensor "jumps" of 4096 (or 1024 for analog) units.
     *
     * @param feedbackNotContinuous     True to disable the overflow tracking.
     *
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configFeedbackNotContinuous(boolean feedbackNotContinuous, int timeoutMs);

    /**
     * Disables going to neutral (brake/coast) when a remote sensor is no longer detected.
     *
     * @param remoteSensorClosedLoopDisableNeutralOnLOS     disable going to neutral
     *
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configRemoteSensorClosedLoopDisableNeutralOnLOS(boolean remoteSensorClosedLoopDisableNeutralOnLOS, int timeoutMs);

    /**
     * Enables clearing the position of the feedback sensor when the forward
     * limit switch is triggered.
     *
     * @param clearPositionOnLimitF     Whether clearing is enabled, defaults false
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configClearPositionOnLimitF(boolean clearPositionOnLimitF, int timeoutMs);

    /**
     * Enables clearing the position of the feedback sensor when the reverse
     * limit switch is triggered
     *
     * @param clearPositionOnLimitR     Whether clearing is enabled, defaults false
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configClearPositionOnLimitR(boolean clearPositionOnLimitR, int timeoutMs);

    /**
     * Enables clearing the position of the feedback sensor when the quadrature index signal
     * is detected
     *
     * @param clearPositionOnQuadIdx    Whether clearing is enabled, defaults false
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configClearPositionOnQuadIdx(boolean clearPositionOnQuadIdx, int timeoutMs);

    /**
     * Disables limit switches triggering (if enabled) when the sensor is no longer detected.
     *
     * @param limitSwitchDisableNeutralOnLOS    disable triggering
     *
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configLimitSwitchDisableNeutralOnLOS(boolean limitSwitchDisableNeutralOnLOS, int timeoutMs);

    /**
     * Disables soft limits triggering (if enabled) when the sensor is no longer detected.
     *
     * @param softLimitDisableNeutralOnLOS    disable triggering
     *
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSoftLimitDisableNeutralOnLOS(boolean softLimitDisableNeutralOnLOS, int timeoutMs);

    /**
     * Sets the edges per rotation of a pulse width sensor. (This should be set for
     * tachometer use).
     *
     * @param pulseWidthPeriod_EdgesPerRot    edges per rotation
     *
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configPulseWidthPeriod_EdgesPerRot(int pulseWidthPeriod_EdgesPerRot, int timeoutMs);

    /**
     * Sets the number of samples to use in smoothing a pulse width sensor with a rolling
     * average. Default is 1 (no smoothing).
     *
     * @param pulseWidthPeriod_FilterWindowSz   samples for rolling avg
     *
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configPulseWidthPeriod_FilterWindowSz(int pulseWidthPeriod_FilterWindowSz, int timeoutMs);

    /**
     * Clears all sticky faults.
     *
     * @return Last Error Code generated by a function.
     */
    public ErrorCode clearStickyFaults();

    /**
     * Sets the value of a custom parameter. This is for arbitrary use.
     *
     * Sometimes it is necessary to save calibration/limit/target information in
     * the device. Particularly if the device is part of a subsystem that can be
     * replaced.
     *
     * @param newValue
     *            Value for custom parameter.
     * @param paramIndex
     *            Index of custom parameter [0,1]
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSetCustomParam(int newValue, int paramIndex);

    /**
     * Gets the value of a custom parameter.
     *
     * @param paramIndex
     *            Index of custom parameter [0,1].
     * @return Value of the custom param.
     */
    public int configGetCustomParam(int paramIndex);

    /**
     * Sets a parameter. Generally this is not used. This can be utilized in -
     * Using new features without updating API installation. - Errata
     * workarounds to circumvent API implementation. - Allows for rapid testing
     * / unit testing of firmware.
     *
     * @param param
     *            Parameter enumeration.
     * @param value
     *            Value of parameter.
     * @param subValue
     *            Subvalue for parameter. Maximum value of 255.
     * @param ordinal
     *            Ordinal of parameter.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSetParameter(ParamEnum param, double value, int subValue, int ordinal);

    /**
     * Sets a parameter.
     *
     * @param param
     *            Parameter enumeration.
     * @param value
     *            Value of parameter.
     * @param subValue
     *            Subvalue for parameter. Maximum value of 255.
     * @param ordinal
     *            Ordinal of parameter.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSetParameter(int param, double value, int subValue, int ordinal);

    /**
     * Gets a parameter.
     *
     * @param param
     *            Parameter enumeration.
     * @param ordinal
     *            Ordinal of parameter.
     * @return Value of parameter.
     */
    public double configGetParameter(ParamEnum param, int ordinal);

    /**
     * Gets a parameter.
     *
     * @param param
     *            Parameter enumeration.
     * @param ordinal
     *            Ordinal of parameter.
     * @return Value of parameter.
     */
    public double configGetParameter(int param, int ordinal);

    /**
     * Set the control mode and output value so that this motor controller will
     * follow another motor controller. Currently supports following Victor SPX,
     * Talon SRX, and Talon FX.
     *
     * @param masterToFollow
     *						Motor Controller object to follow.
     * @param followerType
     *						Type of following control.  Use AuxOutput1 to follow the master
     *						device's auxiliary output 1.
     *						Use PercentOutput for standard follower mode.
     */
    public void follow(IMotorController masterToFollow, FollowerType followerType);

    /**
     * Configures all slot persistant settings (overloaded so timeoutMs is 50 ms
     * and slotIdx is 0
     *
     * @param slot        Object with all of the slot persistant settings
     *
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configureSlot( SlotConfiguration slot);

    /**
     * Configures all slot persistant settings
     *
     * @param slot        Object with all of the slot persistant settings
     * @param slotIdx	  Index of slot to configure
     * @param timeoutMs
     *              Timeout value in ms. If nonzero, function will wait for
     *              config success and report an error if it times out.
     *              If zero, no blocking or checking is performed.
     *
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configureSlot( SlotConfiguration slot, int slotIdx, int timeoutMs);

    /**
     * Gets all slot persistant settings.
     *
     * @param slot        Object with all of the slot persistant settings
     * @param slotIdx     Parameter slot for the constant.
     * @param timeoutMs
     *              Timeout value in ms. If nonzero, function will wait for
     *              config success and report an error if it times out.
     *              If zero, no blocking or checking is performed.
     */
    public void getSlotConfigs(SlotConfiguration slot, int slotIdx, int timeoutMs);

    /**
     * Gets all slot persistant settings (overloaded so timeoutMs is 50 ms
     * and slotIdx is 0
     *
     * @param slot        Object with all of the slot persistant settings
     */
    public void getSlotConfigs( SlotConfiguration slot);

    /**
     * Gets all filter persistant settings.
     *
     * @param filter        Object with all of the filter persistant settings
     * @param ordinal       0 for remote sensor 0 and 1 for remote sensor 1.
     * @param timeoutMs
     *              Timeout value in ms. If nonzero, function will wait for
     *              config success and report an error if it times out.
     *              If zero, no blocking or checking is performed.
     */
    public void getFilterConfigs(FilterConfiguration filter, int ordinal, int timeoutMs);

    /**
     * Gets all filter persistant settings (overloaded so timeoutMs is 50 ms
     * and ordinal is 0).
     *
     * @param filter        Object with all of the filter persistant settings
     */
    public void getFilterConfigs(FilterConfiguration filter);
}
